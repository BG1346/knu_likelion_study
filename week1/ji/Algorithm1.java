//0번부터 차례대로 번호 매겨진 n개의 원소 중 네 개를 고르는 모든 경우를 출력하는 코드를 작성해보자.
//예를 들어 n=7이라면 (0, 1, 2, 3), (0, 1, 2, 4), … ,(3, 4, 5, 6)의 모든 경우를 출력하는 거다.

// 4개를 검색할 때 검색할 첫항이 결정되었으면 무조건 다음항 부터 검사 (4개의 항중 전항이 결정되면 그 다음에 올 항의 데이터는 전항데이터의 다음 인덱스부터  +1씩 늘리면서  (마지막인덱스-(자기항위치-1))(input값-(1*자기항위치))
// 출력할 숫자 == 자신이 위치한 인덱스

//(input값, 몇개를 뽑을지(4개)

public class Algorithm1 {

	public static void main(String[] args) {
		int input = 7; // 0부터 차례대로 번호가 매겨진 7개의 원소 -> [0,1,2,3,4,5,6]
		
		// a,b,c,d 는 4개의 원소 a=첫번째항 b=두번째항..== 7개 중에 4개를 차례대로 뽑아 만들수 있는 모든 경우를 출력하는 것
		for(int a = 0; a <= input; a++) { //첫번째 항을 뽑고 
			for(int b = a+1; b <= input; b++) { //두번째항을 뽑고, 하지만 전항이 뽑은 것 보다 큰 것을 뽑아야 한다.
				for(int c = b+1; c <= input; c++) { // 세번째항을 뽑고, 위와 동일
					for(int d = c+1; d <= input; d ++) { // 네번째.. 위와동일
						System.out.printf("[%d, %d, %d, %d]\n", a,b,c,d); //뽑아서 만들어진 항을 출력
					}
				}
			}
		}
		/* 하지만 각 for문의 조건식을 모두 input으로 해주었을 경우 모든 for문이 끝까지 수행될 것이라고 생각되어 
		 *각for문마다 접근할 수 있는 마지막 값을 다르게 지정해줘야 할 것같지만(밑의 코드처럼)
		 * for(int a = 0; a <= (input-1) - 3; a++) { 
			for(int b = a+1; b <= (input-1) - 2; b++) {
				for(int c = b+1; c <= (input-1) - 1; c++) {
					for(int d = c+1; d <= (input-1); d ++) {
						System.out.printf("[%d, %d, %d, %d]\n", a,b,c,d);
					}
				}
			}
		}
		"해줄필요없음"
		 왜? 결국 실행하는 부분은 가장 내부의 for문인데 
		 내부for문의 조건식을 보면 무조건 input값보다 작을 때 실행하게 된다.
		 즉, 가장 외부for문의 초기값이 내부for문으로 들어오면서 +1씩 증가하여 가장 내부의 있는 for문이 공통된 조건식에서 False가 되어 아예 실행이 되지 않는다. 
		 결국 가장 외부의 for문의 초기값으로 [ input 개수 - 4(==for문의 개수) ] 가 넘어가게 되면 내부의 모든 for문은 조건식에 의해 차례대로 아예 실행을 하지 않게 된다.
		
		 즉 위와 같이
		 모든 for문의 조건식이 공통된 값까지 반복하고
		 자식 for문의 초기값이 부모for문이 결정한 초기값+1인  구조를 갖는
		 N증 for문이라면
		 가장 외부의 for문이 초기값으로 [공통된 값 - N] 을 초과해서 부여하게 된다면
		 가장 내부의 있는 for문부터 차례대로 실행을 하지 못하게 된다.*/ 
	}

}
