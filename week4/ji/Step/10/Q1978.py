'''
백준 단계별풀기 step 10
https://www.acmicpc.net/problem/1978
'''

'''
약수 = 어떤수로 나누었을 때 나머지가 0인 수
소수 = 약수중 1과 자기 자신뿐인 수(단, 1은 소수가 x)

소수를 걸러내는 규칙은 없음
'에라토스체네스의 체' 방법을 이용해 배수들을 지워나가는 방법을 이용
만약 1~100 까지에서 소수를 구해야 한다면
2의배수, 3의배수, 5의배수 등의 순서로 수를 지워나가는 법

즉, 탐색하는 수가
탐색하는 수보다 작은 기존의 소수를 포함한 곱으로 표현이 불가할 때 소수
왜?
소수가 추가될때마다 소수를 포함한 배수들은 모두 제거 
기존의 소수의 배수들을 제거했는데도 남아있는 수라면 그 수는 소수 
 
기존의 소수의 곱셈으로 표현가능 하다면 소수가 아니므로
그 수의 배수를 모두 제외
'''
'''
입력한 수를 2부터 입력한 수 이전까지 나눴을 때 나머지가 0이 아니라면 소수
# 100 * 1000 일경우 100번 * 999번을 해야함

# 밑의 알고리즘의 경우 max를 찾아야 하는 시간복잡도가 추가되지만
# max를 기준으로 1~max사이의 소수를 찾기위해 한 사이클당
하위소수의 개수만큼만 반복하므로
# 시간복잡도 유리

# 1. 입력한 수들 중 가장 큰 max를 찾음
# 2. max를 기준으로 1~max사이의 소수를 찾음
# 3. 입력한 수가 2에서 찾은 소수들 중 하나 인지 확인
'''
# 1. 가장 max값 구하기
count = int(input()) # 입력할 개수
data = list(map(int, input().split())) # 입력할 데이터

max = max(data) # 입력한 수중 가장 큰 값

# 2.1~max사이의 소수 찾기
prime = [] # 소수를 저장할 배열

# 1은 소수가 아니므로 2부터 검색
for num in range(2,max+1) :
    IsPrime = True  # 소수인지 판별

    for p in prime :
        if num % p == 0 : # 소수의 곱으로 표현가능
            IsPrime = False
            break # (한번이라도 표현가능하다면 종료)

    if IsPrime : # 모든 소수의 곱으로 표현이 불가하다면 소수
        prime.append(num) # 소수추가
#3. 입력 data가 max사이의 소수들 중 하나인지 확인하여 개수찾기
prime_count = 0
for num in data :
    if num in prime:
        prime_count+= 1

print(prime_count)

''' 쩌는 코드 > 무슨말이야;
input()
print(sum((10103**~-A%A<2)-(A in[1,561,645,946])for A in map(int,input().split())))
'''