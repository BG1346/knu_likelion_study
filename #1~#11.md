파이썬의 특징
==========

### 파이썬은 개발 속도가 빠르다
> "Life is too short, You need python." (인생은 너무 짧으니 파이썬이 필요해.)

### 파이썬은 간결하다
다른 사람이 작업한 소스 코드도 한눈에 들어와 이해하기 쉽기 때문에 공동 작업과 유지 보수가 아주 쉽고 편하다.

### 들여쓰기(Indentation)
파이썬은 코드의 들여쓰기로 블록(block)을 구분합니다.
이는 다른 언어들과 구분되는 파이썬만이 가지는 독특한 특징 중 하나로, 들여쓰기가 달라지면 다른 블록으로 인식합니다. 
이 방식은 같은 동작을 수행하는 코드가 좀 더 일관된 모습으로 구성되므로, 다른 사람이 작성한 코드를 좀 더 쉽게 읽을 수 있게 해줍니다.

### 인터프리터(Interpreter) 언어
파이썬은 기본적으로 인터프리터(해석기) 위에서 실행되는 언어입니다.
이러한 인터프리터 언어는 프로그램의 코드가 한 라인씩 순서대로 해석되고 실행되기를 반복합니다. 
따라서 코드가 완전히 작성되지 않아도 작성된 부분까지 테스트를 위해 실행이 가능합니다.
인터프리터 언어는 운영체제에 독립적이므로 윈도우 환경 뿐만 아니라 Mac, Linux 상에서도 실행이 가능합니다.
하지만 아직 파이썬 인터프리터가 없는 안드로이드(android)나 ios 환경에서는 동작하지 않습니다.

### 멀티 패러다임
프로그래밍 패러다임은 크게 절차지향, 객체지향 그리고 함수형 패러다임으로 나눌 수 있는데 파이썬은 이 세 가지 패러다임를 모두 구현할 수 있습니다.
절차지향 패러다임의 대표적인 프로그래밍 언어에는 C언어가 있으며, 객체지향 패러다임 언어에는 Java가 있습니다.
또한, 함수형 패러다임 언어에는 LISP 등이 있습니다.
하지만 파이썬은 이런 패러다임에 구애받지 않고 상황에 맞는 유연한 코딩이 가능합니다.


### 파이썬2, 파이썬3 버전의 대표적 차이점.
* 파이썬3에서는 모든 변수가 객체로 처리됨
* 파이썬3 은 int나누기 결과가 float이 될 수 있음
* 파이썬3에서는 print문에 괄호가 필수
  ```
     print 'hello'
     error, invalid syntax
  ```
* 파이썬3에서는 str과 unicode가 통일.(모든 문자열은 유니코드인 str)
* long -> int로 통일.

### 대화형 쉘(interactive shell)과 에디터 모드(editor 모드)의 차이
#### 대화형 쉘
파이썬 쉘 (대화형 쉘)에서는 실행문이 
하나씩 실행 및 종료되기 때문에 바로 결과를 확인할 수 있음 (10여줄 이하 코드 작성에 적합)
파이썬의 셸에서는 print의 도움 없이도 숫자나 텍스트를 출력할 수 있습니다. 숫자의 경우에는 
그대로 입력하고 엔터를 치면 그대로 출력이 될 것이고, 텍스트의 경우에는 ‘ ‘, ” ” 안에 내용을 
입력하여야 합니다. 그렇지 않으면 파이썬 코드인 줄 알고 실행했다가 에러를 발생합니다.
#### 에디터 모드
긴 코드 작성에 적합.

### input()
input() 함수로 사용자가 어떤 값을 입력하게 하고, 그 값을 변수에 저장할 수 있습니다.
입력할 값에 대한 안내를 출력하고 싶다면
```
>>> x = input('name : ')
name : JB
>>> x
'JB'
```


정수로 저장하고 싶다면 int() 함수를 이용합니다.
```
>>> x = int(input('number : '))
number : 123
>>> x
123
```

variable
=========
변수는 상자가 아니다. 파이썬에서 변수에는 값이 저장되는 것이 아닌 객체를 참조한다. 파이썬에서는 거의 모든 것이 객체
많은 책에서 변수를 상자로 표현하고 있는데, 객체지향 언어에서는 이 개념이 참조 변수를 이해하는데 방해가 됨
변수는 객체에 붙은 레이블이라고 생각하는 것이 좋음, 포스트잇.

### 정체성, 동질성, 별명
동일한 객체를 참조하는 사례
```
  byeon = {'name': 'Seongyun', 'born': 1990}
  kyle = byeon
  kyle is byeon
  >>> True
  id(kyle), id(byeon)
  >>> (430048989, 430048989)
  kyle['age'] = 29
  byeon
  >>> {'name': 'Seongyun', 'born': 1990, 'age': 29}
```
  
값은 같으나 정체성이 다른 사례
```
  byeonzzi = {'name': 'Seongyun', 'born': 1990, 'age': 29}
  byeonzzi == byeon
  >>> True
  byeonzzi is not byeon
  >>> True
```
  
byeonzzi와 byeon은 동일한 값을 가지고 있기 때문에 == 연산자에 의해 동일하다고 판단
하지만 정체성은 다름. a is not b는 두 객체의 정체성이 다르다고 표현하는 파이썬 방식
정체성은 메모리 내의 객체 주소라 생각할 수 있으며 is 연산자가 두 객에츼 정체성을 비교
id() 함수로 정체성의 id를 반환. 실제 프로그래밍에선 주로 is 연산자 사용

### 소소한 파이썬 언어의 특징
대소문자구별, 한국말 가능(유니코드 사용), 특수문자 가능, 숫자시작 불가능.띄어쓰기 불가능

datatype
========

### 자료형
정수    	123, -345, 0
실수	    123.45, -1234.5, 3.4e10
복소수	    1+2j, -3j
8진수	    0o34, 0o25
16진수	  0x2A, 0xFF

### 자료형의 기본 논리 반환값
자료형	           값        	참 | 거짓

문자열	       "python"  	      참
	              ""	         거짓
리스트	      [1, 2, 3]	        참
	              []           거짓
튜플	           ()           거짓
딕셔너리	        {}	         거짓
숫자형     	0이 아닌 숫자      	참
	              0            거짓
      	       None   	     거짓

### 문자열을 표현하는 4가지 방법
	1. "hello"
	2. 'hello'
	3. """hello"""
	4. '''hello'''

### 문자열 안에 '나 "를 넣고 싶을 때
1. '는 "로 둘러싸여야 하고, "는 '로 둘러싸여야 한다.
	"Python's very easy."
	'"Python" is very easy.'

		
2. \를 사용하여 '와 "를 문자열에 포함시키기
	"Python\'s very easy."
	"\"Python\" is very easy."
### 여러줄의 문자열을 하나의 변수에 대입하고 싶을 때
1. 개행문자 넣기
```
line = "life is too short\nYou need python"
```
2. 연속된 ''', """
```
line = """
life is too short
You need python
"""
    
line = '''
life is too short
You need python
'''
```

### 연산자의 오류
```
>>> a=[1, 2, 3, 4, 5]
>>> a[2]+"hi"
error
```

3이라는 정수와 "hi"라는 문자열은 더할 수 없기 때문에 형 오류가 발생한다.
숫자 3을 문자 3으로 바꿔 해결할 수 있다.
```
str(a[2]) + "hi"
```



list
====
### 생성예시
```
a = []
b = [1, 2, 3]
c = ['Life', 'is', 'too', 'short']
d = [1, 2, 'Life', 'is']
e = [1, 2, ['Life', 'is']]
```

리스트에는 한 가지의 자료형만 넣을 수 있는게 아닌 여러가지의 자료형을 하나의 리스트에 넣을 수 있다. 
비어있는 리스트는 a=list()로 생성할 수 잇다.

### 리스트의 인덱싱과 슬라이싱
```
>>>a = [1, 2, 3]
>>>a
[1, 2, 3]
>>>a[0]
1
>>>a[-1]
3
```

### 리스트 안의 리스트
```
>>>a=[1, 2, 3, ['a', 'b', 'c']]
>>>a[-1][0]
'a'
>>>a[-1][2]
'c'
```

### 삼중 리스트 인덱싱
```
>>>a=[1, 2, ['a', 'b', ['Life', 'is']]]
>>>a[2][2][0]
'Life'
```

### 리스트 슬라이싱
```
>>>a=[1, 2, 3, 4, 5]
>>>a[0:2]
[1, 2]
```

### 중첩된 리스트의 슬라이싱
```
>>> a=[1, 2, 3, ['a', 'b', 'c'], 4, 5]
>>> a[2:5]
[3, ['a', 'b', 'c'], 4]
>>>a[3][:2]
['a', 'b']
```

### 리스트의 카피
리스트의 참조
```
a = [1, 2, 3]
b = a
```
이런 식으로 하면 b와 a는 같은 리스트를 참조하게 된다. a의 내용이 바뀌면 b도 바뀌게 된다.

#### 리스트 내용 카피 하는 법.
1. [:]
리스트 전체를 가리키는 [:]를 이용해서 복사한다.
a = [1, 2, 3]
b = a[:]
2. copy 모듈
from copy import copy            <-- python module
b = copy(a)
	
동일한 객체인지 아닌지의 판단은 is내장 함수를 쓰면 된다.
```
a is b
```

### 리스트 더하기(+)
```
>>> a = [1, 2, 3]
>>> b = [4, 5, 6]
>>> a + b
[1, 2, 3, 4, 5, 6]
```

### 리스트 반복(*)
```
>>> a = [1, 2, 3]
>>> a*3
[1, 2, 3, 1, 2, 3, 1, 2, 3]
```

### 리스트에서 하나의 값 수정하기
```
>>> a=[1, 2, 3]
>>> a[2] = 4
>>> a 
[1, 2, 4]
```

### 리스트에서 연속된 범위의 값 수정하기
```
>>>a = [1, 2, 4]
>>>a[1:2]
[2]
>>>a[1:2] = ['a', 'b', 'c']
>>>a
[1, 'a', 'b', 'c', 4]
```

### 리스트 수정할 때 두가지 방법
```
a = [1, 2, 4]

>>> a[1] = ['a', 'b', 'c']
>>> a
[1, ['a', 'b', 'c'], 4]

a=[1, 2, 4]
>>> a[1:2] = ['a', 'b', 'c']
>>> a
[1, 'a', 'b', 'c', 4]
```

### []사용해 리스트 요소 삭제하기
```
>>> a=[1, 2, 3, 4]
>>> a[1:3] = []
>>> a
[1, 4]
```

### del함수 사용해 리스트 요소 삭제하기
```
>>> a
[1, 'c', 4]
>>> del a[1]
>>> a
[1, 4]
```

### append
```
>>> a = [1, 2, 3]
>>> a.append(4)
>>> a
[1, 2, 3, 4]

>>> a = [1, 2, 3]
>>>  a.append([5, 6])
>>> a
[1, 2, 3, [5, 6,]]
```

### sort
```
>>> a = [1, 4, 3, 2]
>>> a.sort()
>>> a
[1, 2, 3, 4]
```

문자는 알파벳 순서로 정렬할 수 잇다.
```
>>> a = ['a', 'c', 'b']
>>> a.sort()
>>> a
['a', 'b', 'c']
(cf. 여러가지 자료형이 같이 있는 배열은 정렬이 안됨)
```
	
### reverse
reverse함수는 리스트를 역순으로 뒤집어 준다.
```
>>> a = ['a', 'c', 'b']
>>> a.reverse()
>>> a
['b', 'c', 'a']
```

### index
index(x)함수는 리스트에 x라는 값이 잇으면 x의 위치값을 리턴한다.
(x가 리스트 내에 존재하지 않으면 에러를 반환한다.)
```
>>> a=['a', 'b', 'c']
>>> a.index('c')
2
>>>a.index('a')
0
```

### insert
insert(a, b)는 리스트의 a번째 위치에 b를 삽입하는 함수이다.
```
>>> a = [1, 2, 3, 4]
>>> a.insert(2, 'a')
[1, 2, 'a', 3, 4]
```

### remove
remove(x)는 리스트에서 첫 번째로 나오는 x를 삭제하는 함수이다.
```
>>> a=[1, 2, 3, 1, 2, 3]
>>> a.remove(3)
[1, 2, 1, 2, 3]
```

### pop
리스트의 맨 마지막 요소를 돌려 주고 그 요소는 삭제하는 함수이다.
```
>>> a = [1, 2, 3]
>>> a.pop()
3
>>>a
[1, 2]
```
	
pop(x)는 리스트의 x번째 요소를 돌려주고 그 요소는 삭제한다.
```
>>> a=[1, 2, 3]
>>> a.pop(1)
2
>>> a
[1, 3]
```
	
### count
```
>>>a = [1, 2, 3, 1]
>>> a.count(1)
2
```

### extend
extend(x)에서 x에는 list만 올 수 있으며 원래의 a 리스트에 x 리스트를 더하게 된다.
```
>>> a=[1, 2, 3]
>>> a.extend([4, 5])
>>> a
[1, 2, 3, 4, 5]
>>>b = [6, 7]
>>>a.extend(b)
>>>a
[1, 2, 3, 4, 5, 6, 7]
```

### join
```
"<string>".join(<list>)
```
입력받은 <list>를 <string>을 delimiter로 구분하여 string으로 만든다.


tuple
=====
### 생성예시
```
t1 = ()
t2 = (1,)      -> 튜플에서는 1개의 요소만을 가질 때는 요소 뒤에  콤마를 반드시 붙여야 한다.
t3 = (1, 2, 3)
t4 = 1, 2, 3   ->괄호를 무시해도 무방하다.
t5 = ('a', 'b', ('ab', 'cd'))
```
### 튜플과 리스트의 차이점
	- 리스트는 [과 ]으로 둘러싸지만 튜플은 (과 )으로 둘러싼다.
	- 리스트는 그 값의 생성, 삭제 , 수정이 가능하지만 튜플은 그 값을 바꿀 수 없다.
		○ 튜플 요소값 삭제 시 오류
    
### 인덱싱
```
>>> t1 = (1, 2, 'a', 'b')
>>> t1[0]
1

>>>t1[3]
'b'
```

### 슬라이싱
```
>>>t1 = (1, 2, 'a', 'b')
>>>t1[1:]
(2, 'a', 'b')
```

### 튜플 더하기
```
>>> t2 = (3, 4)
>>> t1 + t2
(1, 2, 'a', 'b', 3, 4)
```

### 튜플 곱하기
```
>>> t2 * 3
(3, 4, 3, 4, 3, 4)

>>> t1 = (1, 2, 'a', 'b')
>>> del t1[0]
error
```
		
### 튜플 요소값 변경 시 오류
```
>>>t1 = (1, 2, 'a', 'b')
>>>t1[0] = 'c'
error
```

dictionary
==========

### 개요
"이름" = "홍길동", "생일"= "19961127" 등으로 대응 관계를 나타낼 수 있는 자료형을 연관배열(Associative array), 또는 해시(Hash)라고 한다.
파이썬에서는 이러한 자료형을 딕셔너리(Dictionary) 라고 한다.
딕셔너리는 리스트나 튜플처럼 순차적으로(sequential)해당 요소값을 구하지 않고 Key 를 통해 value를 얻는다. 이것이 바로 딕셔너리의 가장 큰 특징이다.
baseball이라는 단어의 뜻을 찾기 위해 사전의 내용을 순차적으로 모두 검색하는 것이 아니라 baseball이라는 단어가 있는 곳만 펼쳐 보는 것이다.

### 기본적인 딕셔너리
```
{Key1:Value1, Key2:Value2, Key3:Value3..}

>>> dic = {'name' : 'pey', 'phone':'01034677551', 'birth':'1127'}
```

주의사항
* key는 고유한 값이므로 중복되는 key값을 설정해 놓으면 하난를 제외한 나머지 것들이 모두 무시된다는 점을 주의해야 한다. 중복된 key가 생기면 하나만 선택되고 나머지 것들은 무시된다.
* 리스트는 key로 쓸 수 없다. 튜플은 key로 쓸 수 있다.(list는 변하는 값이기 때문)
	-> 딕셔너리의 key는 변하지 않는 값만 들어갈 수 있다. 

### 딕셔너리 쌍 추가
```
>>> a = {1:'a'}
>>>a[2] = 'b'  -> 2는 key, 'b'는 value
>>> a
{2:'b', 1:'a'}

>>> a['name'] = 'pey'
{'name':'pey', 2:'b', 1:'a'}
```

### 딕셔너리 쌍 제거
```
a = {'name':'pey', 3:[1, 2, 3], 2:'b', 1:'a'}
>>> del a[1]
>>> a
{'name': 'pey', 3 : [1, 2, 3], 2:'b'}
```

### 딕셔너리 인덱싱
```
>>> grade = {'pey': 10, 'julliet':99}
>>> grade['pey']
10
>>> grade['julliet']
99
```

